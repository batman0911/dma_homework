\section{Bài 2}

\subsection{Chia để trị}

\subsubsection{Ý tưởng}
Phương pháp chia để trị dựa trên 2 thao tác chính:
\begin{itemize}
    \item Chia (\textit{devide}): phân rã bài toán ban đầu thành các bài toán con có kích thước
    nhỏ hơn, có cùng cách giải.
    \item Trị (\textit{conque}): giải từng bài toán con (theo cách tương tự bài toán đầu - đệ
    qui) rồi tổng hợp các lời giải để nhận kết quả của bài toán ban đầu.
\end{itemize}

Việc “Phân rã”: thực hiện trên miền dữ liệu (chia miền dữ liệu thành các miền
nhỏ hơn tương đương 1 bài toán con)

\subsubsection{Mô hình và lược đồ}
Xét bài toàn $P$ trên miền dữ liệu $R$.

Gọi $D\_C(R)$ là thuật giải $P$ trên miền dữ liệu $R$.

Nếu $R$ có thể phân rã thành $n$ miền con: $R = R_1 \cup R_2 \cup ... \cup R_n$

Với $R_0$ là miền đủ nhỏ để  $D\_C(R)$ có lời giải, ta có lược đồ giải thuật chia để trị như sau:

\begin{lstlisting}[style=algo]
    Divide_Conque($R$):
        if($R = R_0$):
            solve Divide_Conque($R_0$)
        else
            divide $R$ to $R_1, R_2, ..., R_n$
            for ($i = 1, 2, ..., n$):
                Divide_Conque($R_i$)
            Combine and get result
    end
\end{lstlisting}

\subsubsection{Phân tích và đánh giá}
Để phân tích và đánh giá độ phức tạp của thuật toán, ta thực hiện 2 công đoạn

\begin{itemize}
    \item Xây dựng công thức truy hồi đánh giá độ phức tạp thuật toán
    \item Giải công thức truy hồi xác định độ phức tạp thuật toán.
        \begin{itemize}
            \item Phép thế liên tiếp
            \item Sử dụng định lí chính
        \end{itemize}
\end{itemize}


\subsubsection{Ví dụ}
Ta xét bài toán \textit{tìm kiếm nhị phân trên một mảng được sắp xếp}.

\begin{itemize}
    \item Cho dãy $n$ phần tử được sắp theo thứ tự (\textit{tăng dần}) và một giá trị $x$ 
    bất kỳ. Kiểm tra xem phần tử  $x$ có trong dãy không?

    \item Phân tích ý tưởng: so sánh giá trị $x$ với phần tử giữa của dãy tìm kiếm. Dựa
    vào giá trị này sẽ quyết định giới hạn tìm kiếm ở bước kế tiếp là nửa trước
    hay nửa sau dãy.

    \item Lược đồ của thuật toán như sau:

\end{itemize}

\begin{lstlisting}[style=algo]
    BinarySearch($a, x, L, R$):
        // Search element $x$ in array $a$ from position $L$ to $R$
        if ($L = R$):
            return ($x = a_L$ ? $L$ : $-1$)
        else
            $M = (L + R)/2$
            if ($x = a_M$) 
                return ($M$)
            else
                if ($x < a_M$)
                    BinarySearch($a, x, L, R$)
                else 
                    BinarySearch($a, x, M + 1, R$)
                endif
            endif
        endif
    end
\end{lstlisting}

\textit{Tính đúng của thuật toán}

Ta chứng mình bằng quy nạp như sau 
\begin{itemize}
    \item Cơ sở quy nạp: $n = R - L + 1 = 1$ (dãy có 1 phần tử)
    \begin{itemize}
        \item Câu lệnh \lstinline{return (x = a_L ? L : -1)} trả về giá trị $L$ hoặc $-1$
    \end{itemize}
    
    \item Giả thiết quy nạp: Thuật toán đúng với mọi dãy có độ dài $n = R-L+1$.
    Hay hàm \lstinline{BinarySearch(a, x, L, R)} trả về đúng kết quả tìm kiếm $x$ với mọi dãy
    có đội dài $1 \leq n' \leq n = R - L + 1$

    \item Tổng quát: Chứng minh thuật toán đúng với $n+1 = R-L+2$
    \begin{itemize}
        \item Đặt $M=(L+R+1)/2$, ta có $L \leq M \leq R$
        \item Nếu $x = a_M$ thì kết quả trả về là $M$: đúng
        \item Nếu $x < a_M$ thì kết quả là của bài toán tìm $x$ trong tập $a_L, ... , a_M$.
        Theo giả thiết quy nạp thì \lstinline{BinarySearch(a, x, L, R)} đúng vì 
        $1 \leq M - L + 1 = (R - L + 1)/2 + 1 \leq R - L + 1$
        \item Tương tự với $x > a_M$
    \end{itemize}
\end{itemize}

\textit{Độ phức tạp của thuật toán}

\begin{equation*}
    T(n) = 
    \begin{cases}
        1 & \text{when } n = 1 \\
        T(n/2) + 1 & \text{when } n > 1
    \end{cases}
\end{equation*}

Do đó $T(n) = O(\log n)$



